#![allow(warnings)]

use std::{
    fs::{self, File},
    io::{Read, Write},
};

use rbsigner::signer::RBHeader;

fn main() {
    let mut buf = Vec::new();
    let mut buf1 = [0u8; 4096]; // 4kb array
    let mut i = 0;
    let mut file = fs::File::open(
        std::env::args()
            .nth(1)
            .expect("Need path to bin file as argument"),
    )
    .unwrap();
    file.read_to_end(&mut buf).unwrap();

    let mut rb_header = RBHeader::<[u8; 256]>::new_checked([0; 256]).unwrap();

    let tsv: [u8; 8] = [0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22];
    let tv: [u8; 4] = [0x01, 0x02, 0x03, 0x04];
    let img: [u8; 2] = [0x02, 00];
    let sha256_digest: [u8; 0x20] = [
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
        0x33, 0x33,
    ];

    let pubkey_digest: [u8; 0x20] = [
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55,
    ];

    let signature_value: [u8; 0x40] = [
        0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
        0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
        0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
        0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
        0x44, 0x44, 0x44, 0x44,
    ];



    rb_header.set_magic_key(0x52555354);
    rb_header.set_magic_key_size(0x65514854);
    rb_header.set_version_type_len(0x00010004);
    rb_header.set_version_value(&tv);
    // rb_header.set_padding(&[0xff; 4]);
    rb_header.set_timestamp_type_len(0x02000800);
    rb_header.set_timestamp_value(&tsv);
    rb_header.set_image_type_len(0x04000200);
    rb_header.set_image_value(&img);
    // rb_header.set_padding(&[0xff; 6]);
    rb_header.set_digest_type_len(0x03002000);
    rb_header.set_sha256_digest_value(&sha256_digest);
    rb_header.set_pubkey_type_len(0x10002000);
    rb_header.set_pubkey_digest_value(&pubkey_digest);
    rb_header.set_signature_type_len(0x20004000);
    rb_header.set_signatue_value(&signature_value);
    // rb_header.set_padding(&[0xff; 70]);
    rb_header.set_end_of_header(0x0000);

    for x in rb_header.inner_ref().as_ref()[..256].iter() {
        buf1[i] = *x;
        i = i + 1;
    }
    for x in buf {
        buf1[i] = x;
        i = i + 1;
    }

    let mut file3 = File::create("bootloader_patch.bin").expect("couldnt create file3");
    file3.write_all(&buf1).expect("couldnt write in file3");

    println!("rustBoot header {:x?}", rb_header);
}
